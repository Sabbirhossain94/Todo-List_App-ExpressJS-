"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Editor = void 0;
const path = __importStar(require("path"));
const events_1 = require("events");
const fs_1 = require("fs");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const service_provider_core_1 = require("@mongosh/service-provider-core");
const shell_api_1 = require("@mongosh/shell-api");
const beautify = require('js-beautify').js;
class Editor {
    constructor({ input, vscodeDir, tmpDir, instanceState, makeMultilineJSIntoSingleLine, loadExternalCode }) {
        this._input = input;
        this._vscodeDir = vscodeDir;
        this._tmpDir = tmpDir;
        this._instanceState = instanceState;
        this._makeMultilineJSIntoSingleLine = makeMultilineJSIntoSingleLine;
        this._loadExternalCode = loadExternalCode;
        this._lastContent = '';
        this.print = instanceState.context.print;
        const wrapperFn = (input) => {
            return Object.assign(this.runEditCommand(input), {
                [Symbol.for('@@mongosh.syntheticPromise')]: true
            });
        };
        wrapperFn.isDirectShellCommand = true;
        wrapperFn.returnsPromise = true;
        wrapperFn.acceptsRawInput = true;
        instanceState.shellApi.edit = instanceState.context.edit = wrapperFn;
        shell_api_1.signatures.ShellApi.attributes.edit = {
            type: 'function',
            returnsPromise: true,
            isDirectShellCommand: true,
            acceptsRawInput: true
        };
    }
    static create(options) {
        return new Editor(options);
    }
    async _getExtension(cmd) {
        if (!this._isVscodeApp(cmd)) {
            return 'js';
        }
        try {
            const extensions = await fs_1.promises.readdir(path.join(this._vscodeDir, 'extensions'));
            const hasMongodbExtension = !!extensions
                .find((name) => name.includes('mongodb.mongodb-vscode'));
            this.messageBus.emit('mongosh-editor:read-vscode-extensions-done', {
                vscodeDir: this._vscodeDir,
                hasMongodbExtension
            });
            return hasMongodbExtension ? 'mongodb' : 'js';
        }
        catch (error) {
            this.messageBus.emit('mongosh-editor:read-vscode-extensions-failed', {
                action: 'mongosh-editor:read-vscode-extensions-failed',
                error: error.message
            });
            return 'js';
        }
    }
    async _getEditor() {
        let editor = await this._instanceState.shellApi.config.get('editor');
        if (!editor && process.env.EDITOR) {
            editor = process.env.EDITOR;
        }
        return editor;
    }
    async _createTempFile({ content, ext }) {
        const tmpDoc = path.join(this._tmpDir, `edit-${new service_provider_core_1.bson.ObjectId()}.${ext}`);
        await fs_1.promises.mkdir(path.dirname(tmpDoc), { recursive: true, mode: 0o700 });
        await fs_1.promises.writeFile(tmpDoc, beautify(content), { mode: 0o600 });
        return tmpDoc;
    }
    async _readAndDeleteTempFile(tmpDoc) {
        this._lastContent = await fs_1.promises.readFile(tmpDoc, 'utf8');
        await fs_1.promises.unlink(tmpDoc);
        return this._makeMultilineJSIntoSingleLine(this._lastContent);
    }
    _isVscodeApp(cmd) {
        const regex = /^(.*)[\/\\]?[cC]ode(.exe)?$/;
        return regex.test(cmd);
    }
    _isIdentifier(code) {
        const regex = /^([^!#%&()*+,\-/\\^`{|}~]+)$/;
        return regex.test(code);
    }
    async _getEditorContent(code) {
        if (!code) {
            return this._lastContent;
        }
        if (!this._isIdentifier(code)) {
            return code;
        }
        const evalResult = await this._loadExternalCode(code, '@(editor)');
        return evalResult.toString();
    }
    async runEditCommand(input) {
        await this.print('Opening an editor...');
        const code = input.replace('edit', '').trim();
        const editor = await this._getEditor();
        if (!editor) {
            throw new Error('Command failed with an error: please define an external editor');
        }
        const content = await this._getEditorContent(code);
        const ext = await this._getExtension(editor);
        const tmpDoc = await this._createTempFile({ content, ext });
        this.messageBus.emit('mongosh-editor:run-edit-command', {
            tmpDoc,
            editor,
            code
        });
        const proc = cross_spawn_1.default(editor, [tmpDoc], { stdio: 'inherit' });
        this._input.pause();
        try {
            const [exitCode] = await events_1.once(proc, 'exit');
            if (exitCode === 0) {
                const result = await this._readAndDeleteTempFile(tmpDoc);
                this._input.unshift(result);
                return;
            }
            throw new Error(`Command '${code}' failed with an exit code ${exitCode}`);
        }
        finally {
            this._input.resume();
            if (proc.exitCode === null && proc.signalCode === null) {
                proc.kill();
            }
        }
    }
    get messageBus() {
        return this._instanceState.messageBus;
    }
}
exports.Editor = Editor;
//# sourceMappingURL=editor.js.map